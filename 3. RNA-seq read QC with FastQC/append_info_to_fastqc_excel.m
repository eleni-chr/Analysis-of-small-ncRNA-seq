function append_info_to_fastqc_excel
%% Function written by Dr Eleni Christoforidou in MATLAB R2024a.

% This function appends additional data columns to Excel files generated 
% from FastQC output. The columns added provide reference data relevant 
% to each file type, such as percentage values or sequential indices.
% The function is specifically designed to work with Excel files created 
% by the `extract_fastqc_data_to_excel` function, which extracts data 
% from FastQC output text files and saves them as .xlsx files.
%
% Usage:
% - Ensure the following Excel files exist in the current MATLAB directory, 
%   as generated by the first function (`extract_fastqc_data_to_excel`):
%   - 'Per_sequence_GC_content.xlsx'
%   - 'Per_base_sequence_quality.xlsx'
%   - 'Per_sequence_quality_scores.xlsx'
%   - 'Per_base_N_content.xlsx'
%   - 'Sequence_length_distribution.xlsx'
% - Run the function without any input arguments:
%       append_info_to_fastqc_excel
%
% Function Operation:
% 1. The function opens each of the five specified Excel files.
% 2. It appends a new column to each file, containing reference data specific 
%    to the type of content:
%    - 'Per_sequence_GC_content.xlsx': Adds a column with the header 
%      'Percentage_GC' containing integers from 0 to 100.
%    - 'Per_base_sequence_quality.xlsx': Adds a column with the header 
%      'Base_number' containing integers from 1 to N, where N is the base number of the longest read in the data.
%    - 'Per_sequence_quality_scores.xlsx': Adds a column with the header 
%      'Quality_score' containing integers from N to 34, where N is the
%      lowest quality according to the longest read in the data.
%    - 'Per_base_N_content.xlsx': Adds a column with the header 'Base_number' 
%      containing integers from 1 to N, where N is the base number of the longest read in the data.
%    - 'Sequence_length_distribution.xlsx': Adds a column with the header 
%      'Length' containing integers from 1 to N, where N is the base number of the longest read in the data.
% 3. The modified data is saved back into the original Excel files.
% 
% Notes:
% - Ensure that the Excel files have the correct format and structure as 
%   expected from the previous function. The function assumes the files 
%   exist and are accessible in the current directory.

%%
    % Define the file names
    files = {
        'Per_sequence_GC_content.xlsx', ...
        'Per_base_sequence_quality.xlsx', ...
        'Per_sequence_quality_scores.xlsx', ...
        'Per_base_N_content.xlsx', ...
        'Sequence_length_distribution.xlsx'
    };

% Reverse and append the data in 'Per_sequence_quality_scores.xlsx'
reverse_file = 'Per_sequence_quality_scores.xlsx';
[~, ~, rawData] = xlsread(reverse_file);

% Reverse the order of non-empty data for each column, starting from the second row (ignoring headers)
reversedData = rawData; % Keep the headers in place

for col = 1:size(rawData, 2)
    columnData = rawData(2:end, col); % Get the data below the header
    
    % Remove empty cells (without adding them back later)
    nonEmptyData = columnData(~cellfun(@isempty, columnData));
    
    % Reverse the non-empty data
    reversedNonEmptyData = flipud(nonEmptyData);
    
    % Replace the original data in the reversed order
    reversedData(2:length(reversedNonEmptyData)+1, col) = reversedNonEmptyData;
    
    % If there are fewer reversed values than the original column length, make sure no extra empty rows are added
    reversedData(length(reversedNonEmptyData)+2:end, col) = {[]};
end

% Write the reversed data back to the same file
writecell(reversedData, reverse_file);    

% Loop through each file and append data
for i = 1:length(files)
    % Read the existing data
    [~, ~, existingData] = xlsread(files{i});
    
    % Calculate the number of rows in the existing data
    maxExistingRows = size(existingData, 1);
    
    % Dynamically define the columns to be added based on the current file
    switch files{i}
        case 'Per_sequence_GC_content.xlsx'
            appendData = struct('header', 'Percentage_GC', 'values', (0:100)');
            
        case 'Per_base_sequence_quality.xlsx'
            appendData = struct('header', 'Base_number', 'values', (1:maxExistingRows-1)');
    
        case 'Per_sequence_quality_scores.xlsx'
           % Here the new values are also reversed to match the rest of the columns
            appendData = struct('header', 'Quality_score', 'values', flipud((36-maxExistingRows:34)'));   
        
        case 'Per_base_N_content.xlsx'
            appendData = struct('header', 'Base_number', 'values', (1:maxExistingRows-1)');
            
        case 'Sequence_length_distribution.xlsx'
            appendData = struct('header', 'Length', 'values', (14:maxExistingRows-1+13)'); % starts from 14 because reads <14 nt long have been discarded
    end
    
    % Define the new column to append
    newData = [appendData.header; num2cell(appendData.values)];
    
    % Find the number of rows in the new data
    numNewRows = numel(newData);
    
    % Ensure that all columns in existingData have the same length
    if size(existingData, 1) < maxExistingRows
        % Pad existingData with empty cells to match the longest column
        existingData((end+1):maxExistingRows, :) = {[]};
    end
    
    % Ensure the new data has the same number of rows by padding it if necessary
    if numNewRows < maxExistingRows
        newData((end+1):maxExistingRows, 1) = {[]};
    elseif numNewRows > maxExistingRows
        % Pad the existing data if new data is longer
        existingData((end+1):numNewRows, :) = {[]};
    end
    
    % Append the new data to the existing data
    updatedData = [newData, existingData];
    
    % Write the updated data back to the Excel file
    writecell(updatedData, files{i});
    
    disp(['Data successfully appended to ', files{i}]);
end

 % Fix some issues with 'Per_sequence_quality_scores.xlsx' file
    fileName = 'Per_sequence_quality_scores.xlsx';

    % Read the Excel file
    [~, ~, rawData] = xlsread(fileName);
    
    % Keep the headers intact (first row)
    shiftedData = rawData;  % Initialise the shiftedData with the original data

    % Iterate over each column (starting from the second row)
    for col = 1:size(rawData, 2)
        columnData = rawData(2:end, col); % Get the data excluding the header
        
        % Remove empty cells from the column
        nonEmptyData = columnData(~cellfun(@(x) isempty(x) || (isnumeric(x) && isnan(x)), columnData));
        
        % Count how many NaNs were removed
        numNaNsRemoved = sum(cellfun(@(x) isnan(x), columnData));

        % Place non-empty data back at the top of the column (below the header)
        shiftedData(2:length(nonEmptyData)+1, col) = nonEmptyData;

        % Fill remaining cells below the non-empty data with empty cells
        if length(nonEmptyData) < length(columnData)
            shiftedData(length(nonEmptyData)+2:end, col) = {[]};
        end

        % Append zeros to the end of the column for each NaN removed
        if numNaNsRemoved > 0
            shiftedData(end - numNaNsRemoved + 1:end, col) = {0};  % Replace empty cells with zeros
        end
    end
    
    % Reverse the data in each column (except for the header row)
    for col = 1:size(shiftedData, 2)
        dataToReverse = shiftedData(2:end, col);  % Get data excluding header
        dataToReverse = flipud(dataToReverse);  % Reverse the order
        shiftedData(2:end, col) = dataToReverse;  % Place reversed data back
    end
    
    % Check the first value in column A (excluding header)
    firstValue = shiftedData{2, 1};  % Get the first value in column A
    if firstValue > 1
        % Create new rows in column A with integers from 0 to firstValue-1
        newRows = (1:firstValue-1)';  % Column vector
        
        % Convert newRows to a cell array
        newRowsCell = num2cell(newRows);  % Convert to cell array
        
        % Create a new zero-filled cell array for additional columns
        zerosToAppend = cell(length(newRows), size(shiftedData, 2) - 1);  % Create cell array of zeros
        zerosToAppend(:) = {0};  % Fill with zeros

        % Prepend new rows to shiftedData
        shiftedData = [[{shiftedData{1, :}}; newRowsCell, zerosToAppend]; shiftedData(2:end, :)];  % Insert new rows just below the header
    end
    
    % Write the final modified data back to the Excel file
    writecell(shiftedData, fileName);
end
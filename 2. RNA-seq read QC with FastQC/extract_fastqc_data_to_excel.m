function extract_fastqc_data_to_excel
%% Function written by Dr Eleni Christoforidou in MATLAB R2024a.

% This function reads data from multiple FastQC result text files and 
% extracts specific sections related to sequence quality, GC content, 
% sequence length distribution, N content, and total deduplication percentage.
% The extracted data is then organised and saved into five separate Excel 
% files, one for each type of data. The function is designed to work with 
% .txt files that follow the naming pattern 'P*-*.txt' and are located in 
% the current working directory.
%
% Usage:
% - Place all .txt files generated by FastQC in the current MATLAB directory.
% - Run the function without any input arguments: 
%       extract_fastqc_data_to_excel
%
% Function Operation:
% 1. The function scans the current directory for .txt files matching the 
%    pattern 'P*-*.txt'.
% 2. For each file, it extracts data from the following sections:
%    - Per base sequence quality
%    - Per sequence quality scores
%    - Per sequence GC content
%    - Sequence length distribution
%    - Per base N content
%    - Sequence Duplication Levels
% 3. The data is stored in five Excel files with predefined names:
%    - 'Per_base_sequence_quality.xlsx'
%    - 'Per_sequence_quality_scores.xlsx'
%    - 'Per_sequence_GC_content.xlsx'
%    - 'Sequence_length_distribution.xlsx'
%    - 'Per_base_N_content.xlsx'
%    - 'Total_deduplicated_percentages.xlsx'
% 4. Each Excel file will contain a header row or column with sample IDs 
%    extracted from the filenames and the corresponding data from each sample.
%
% Notes:
% - Ensure the .txt files have consistent formatting as expected by FastQC output.
% - The function assumes the data of interest is located between specific 
%   markers (e.g., '>>Per base sequence quality' and '>>END_MODULE') within each file.

%%
    % Define output Excel file names
    outputFileNameQuality = 'Per_base_sequence_quality.xlsx';
    outputFileNameScores = 'Per_sequence_quality_scores.xlsx';
    outputFileNameGCContent = 'Per_sequence_GC_content.xlsx';
    outputFileNameLengthDist = 'Sequence_length_distribution.xlsx';
    outputFileNameNContent = 'Per_base_N_content.xlsx';
    outputFileNameDedup = 'Total_deduplicated_percentages.xlsx';

    % Get a list of all .txt files in the current directory
    txtFiles = dir('P*-*.txt');
    
    % Initialise cell arrays to hold data for all five outputs
    dataQuality = {};
    headersQuality = {''};
    dataScores = {};
    headersScores = {''};
    dataGCContent = {};
    headersGCContent = {''};
    dataLengthDist = {};
    headersLengthDist = {''};
    dataNContent = {};
    headersNContent = {''};
    dataDedup = {};
    headersDedup = {};

    % Loop through each file
    for i = 1:length(txtFiles)
        % Get the full path of the file
        filePath = fullfile(txtFiles(i).folder, txtFiles(i).name);
        
        % Extract sample ID from the filename (before the first underscore)
        [~, fileName, ~] = fileparts(txtFiles(i).name);
        underscoreIndex = strfind(fileName, '_');
        if ~isempty(underscoreIndex)
            sampleID = fileName(1:underscoreIndex(1)-1);
        else
            sampleID = fileName; % No underscore found, use the entire filename
        end
        
        % Add sample ID to headers for all data sets
        headersQuality{end + 1} = sampleID;
        headersScores{end + 1} = sampleID;
        headersGCContent{end + 1} = sampleID;
        headersLengthDist{end + 1} = sampleID;
        headersNContent{end + 1} = sampleID;
        
        % Open the file
        fid = fopen(filePath, 'r');
        
        % Read the file line by line
        tline = fgetl(fid);
        
        % Initialise flags and data holders for each section
        inQualitySection = false;
        inScoresSection = false;
        inGCContentSection = false;
        inLengthDistSection = false;
        inNContentSection = false;
        valuesQuality = [];
        valuesScores = [];
        valuesGCContent = [];
        valuesLengthDist = [];
        valuesNContent = [];
        inDedupSection = false;
        dedupPercentage = NaN;

        % Loop through each line in the file
        while ischar(tline)
            % Check for the start and end of the Quality section
            if contains(tline, '>>Per base sequence quality')
                inQualitySection = true;
            elseif contains(tline, '>>END_MODULE') && inQualitySection
                % Exit the Quality section when reaching the first END_MODULE
                inQualitySection = false;
            elseif inQualitySection
                % Extract data from the Quality section
                dataParts = strsplit(tline, '\t'); % Split by tab
                if length(dataParts) > 1 && ~strcmp(dataParts{1}, '#Base')
                    % Extract the "Mean" value which is in the second column
                    meanValue = str2double(dataParts{2});
                    if ~isnan(meanValue)
                        valuesQuality = [valuesQuality; meanValue];
                    end
                end
            end
            
            % Check for the start and end of the Scores section
            if contains(tline, '>>Per sequence quality scores')
                inScoresSection = true;
            elseif contains(tline, '>>END_MODULE') && inScoresSection
                % Exit the Scores section when reaching the first END_MODULE
                inScoresSection = false;
            elseif inScoresSection
                % Extract data from the Scores section
                dataParts = strsplit(tline, '\t'); % Split by tab
                if length(dataParts) > 1 && ~strcmp(dataParts{1}, '#Sequence')
                    % Extract the "Count" value which is in the second column
                    countValue = str2double(dataParts{2});
                    if ~isnan(countValue)
                        valuesScores = [valuesScores; countValue];
                    end
                end
            end
            
            % Check for the start and end of the GC Content section
            if contains(tline, '>>Per sequence GC content')
                inGCContentSection = true;
            elseif contains(tline, '>>END_MODULE') && inGCContentSection
                % Exit the GC Content section when reaching the first END_MODULE
                inGCContentSection = false;
            elseif inGCContentSection
                % Extract data from the GC Content section
                dataParts = strsplit(tline, '\t'); % Split by tab
                if length(dataParts) > 1 && ~strcmp(dataParts{1}, '#GC_content')
                    % Extract the "Count" value which is in the second column
                    countValue = str2double(dataParts{2});
                    if ~isnan(countValue)
                        valuesGCContent = [valuesGCContent; countValue];
                    end
                end
            end
            
            % Check for the start and end of the Length Distribution section
            if contains(tline, '>>Sequence Length Distribution')
                inLengthDistSection = true;
            elseif contains(tline, '>>END_MODULE') && inLengthDistSection
                % Exit the Length Distribution section when reaching the first END_MODULE
                inLengthDistSection = false;
            elseif inLengthDistSection
                % Extract data from the Length Distribution section
                dataParts = strsplit(tline, '\t'); % Split by tab
                if length(dataParts) > 1 && ~strcmp(dataParts{1}, '#Length')
                    % Extract the "Count" value which is in the second column
                    countValue = str2double(dataParts{2});
                    if ~isnan(countValue)
                        valuesLengthDist = [valuesLengthDist; countValue];
                    end
                end
            end

            % Check for the start and end of the N Content section
            if contains(tline, '>>Per base N content')
                inNContentSection = true;
            elseif contains(tline, '>>END_MODULE') && inNContentSection
                % Exit the N Content section when reaching the first END_MODULE
                inNContentSection = false;
            elseif inNContentSection
                % Extract data from the N Content section
                dataParts = strsplit(tline, '\t'); % Split by tab
                if length(dataParts) > 1 && ~strcmp(dataParts{1}, '#Base')
                    % Extract the "N-Count" value which is in the second column
                    nCountValue = str2double(dataParts{2});
                    if ~isnan(nCountValue)
                        valuesNContent = [valuesNContent; nCountValue];
                    end
                end
            end

            % Check for the start and end of the Deduplication section
            if contains(tline, '>>Sequence Duplication Levels')
                inDedupSection = true;
            elseif contains(tline, '>>END_MODULE') && inDedupSection
                inDedupSection = false;
            elseif inDedupSection
                if contains(tline, '#Total Deduplicated Percentage')
                    dataParts = strsplit(tline, '\t');
                    if length(dataParts) > 1
                        dedupPercentage = str2double(dataParts{2});
                    end
                end
            end
            
            % Read the next line
            tline = fgetl(fid);
        end
        
        % Close the file
        fclose(fid);
        
        % Add the extracted values to data for Quality
        if isempty(dataQuality)
            % First time populating data, initialise rows with NaNs
            maxLengthQuality = length(valuesQuality);
            dataQuality = num2cell(nan(maxLengthQuality, 1)); % Create column with NaNs
        end
        
        % Resize values to fit the max length by padding with NaNs if needed
        if length(valuesQuality) < size(dataQuality, 1)
            valuesQuality = [valuesQuality; nan(size(dataQuality, 1) - length(valuesQuality), 1)];
        elseif length(valuesQuality) > size(dataQuality, 1)
            % Pad all previous columns with NaNs to match the new length
            dataQuality = [dataQuality; num2cell(nan(length(valuesQuality) - size(dataQuality, 1), size(dataQuality, 2)))];
        end
        
        % Append values as a new column to dataQuality
        dataQuality(:, end + 1) = num2cell(valuesQuality);
        
        % Add the extracted values to data for Scores
        if isempty(dataScores)
            % First time populating data, initialise rows with NaNs
            maxLengthScores = length(valuesScores);
            dataScores = num2cell(nan(maxLengthScores, 1)); % Create column with NaNs
        end
        
        % Resize values to fit the max length by padding with NaNs if needed
        if length(valuesScores) < size(dataScores, 1)
            valuesScores = [valuesScores; nan(size(dataScores, 1) - length(valuesScores), 1)];
        elseif length(valuesScores) > size(dataScores, 1)
            % Pad all previous columns with NaNs to match the new length
            dataScores = [dataScores; num2cell(nan(length(valuesScores) - size(dataScores, 1), size(dataScores, 2)))];
        end
        
        % Append values as a new column to dataScores
        dataScores(:, end + 1) = num2cell(valuesScores);
        
        % Add the extracted values to data for GC Content
        if isempty(dataGCContent)
            % First time populating data, initialise rows with NaNs
            maxLengthGCContent = length(valuesGCContent);
            dataGCContent = num2cell(nan(maxLengthGCContent, 1)); % Create column with NaNs
        end
        
        % Resize values to fit the max length by padding with NaNs if needed
        if length(valuesGCContent) < size(dataGCContent, 1)
            valuesGCContent = [valuesGCContent; nan(size(dataGCContent, 1) - length(valuesGCContent), 1)];
        elseif length(valuesGCContent) > size(dataGCContent, 1)
            % Pad all previous columns with NaNs to match the new length
            dataGCContent = [dataGCContent; num2cell(nan(length(valuesGCContent) - size(dataGCContent, 1), size(dataGCContent, 2)))];
        end
        
        % Append values as a new column to dataGCContent
        dataGCContent(:, end + 1) = num2cell(valuesGCContent);
        
        % Add the extracted values to data for Length Distribution
        if isempty(dataLengthDist)
            % First time populating data, initialise rows with NaNs
            maxLengthLengthDist = length(valuesLengthDist);
            dataLengthDist = num2cell(nan(maxLengthLengthDist, 1)); % Create column with NaNs
        end
        
        % Resize values to fit the max length by padding with NaNs if needed
        if length(valuesLengthDist) < size(dataLengthDist, 1)
            valuesLengthDist = [valuesLengthDist; nan(size(dataLengthDist, 1) - length(valuesLengthDist), 1)];
        elseif length(valuesLengthDist) > size(dataLengthDist, 1)
            % Pad all previous columns with NaNs to match the new length
            dataLengthDist = [dataLengthDist; num2cell(nan(length(valuesLengthDist) - size(dataLengthDist, 1), size(dataLengthDist, 2)))];
        end
        
        % Append values as a new column to dataLengthDist
        dataLengthDist(:, end + 1) = num2cell(valuesLengthDist);
        
        % Add the extracted values to data for N Content
        if isempty(dataNContent)
            % First time populating data, initialise rows with NaNs
            maxLengthNContent = length(valuesNContent);
            dataNContent = num2cell(nan(maxLengthNContent, 1)); % Create column with NaNs
        end
        
        % Resize values to fit the max length by padding with NaNs if needed
        if length(valuesNContent) < size(dataNContent, 1)
            valuesNContent = [valuesNContent; nan(size(dataNContent, 1) - length(valuesNContent), 1)];
        elseif length(valuesNContent) > size(dataNContent, 1)
            % Pad all previous columns with NaNs to match the new length
            dataNContent = [dataNContent; num2cell(nan(length(valuesNContent) - size(dataNContent, 1), size(dataNContent, 2)))];
        end
        
        % Append values as a new column to dataNContent
        dataNContent(:, end + 1) = num2cell(valuesNContent);

        % Add the extracted values to data for Deduplication Percentage
        headersDedup{end + 1} = sampleID;
        dataDedup{end + 1, 1} = dedupPercentage;
    end
    
    % Combine headers and data for Quality
    outputDataQuality = [headersQuality; dataQuality];
    
    % Combine headers and data for Scores
    outputDataScores = [headersScores; dataScores];
    
    % Combine headers and data for GC Content
    outputDataGCContent = [headersGCContent; dataGCContent];
    
    % Combine headers and data for Length Distribution
    outputDataLengthDist = [headersLengthDist; dataLengthDist];
    
    % Combine headers and data for N Content
    outputDataNContent = [headersNContent; dataNContent];
    
    % Write to Excel files
    writecell(outputDataQuality, outputFileNameQuality);
    writecell(outputDataScores, outputFileNameScores);
    writecell(outputDataGCContent, outputFileNameGCContent);
    writecell(outputDataLengthDist, outputFileNameLengthDist);
    writecell(outputDataNContent, outputFileNameNContent);

    DedupTable = cell2table([headersDedup', dataDedup]);
    DedupTable.Properties.VariableNames = {'Sample_ID', 'Total_deduplicated_percentage'};
    writetable(DedupTable, outputFileNameDedup);
    
    disp(['Data successfully written to ', outputFileNameQuality]);
    disp(['Data successfully written to ', outputFileNameScores]);
    disp(['Data successfully written to ', outputFileNameGCContent]);
    disp(['Data successfully written to ', outputFileNameLengthDist]);
    disp(['Data successfully written to ', outputFileNameNContent]);
    disp(['Data successfully written to ', outputFileNameDedup]);
end
